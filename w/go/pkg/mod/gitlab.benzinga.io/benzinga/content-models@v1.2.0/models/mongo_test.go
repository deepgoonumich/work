package models

import (
	"encoding/json"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"gopkg.in/mgo.v2/bson"
)

func TestIDWrapper(t *testing.T) {
	type TestVal struct {
		ID PHPObjID `bson:"_id"`
	}

	tests := []struct {
		Value   string
		BSON    []byte
		JSONIn  []byte
		JSONOut []byte
	}{
		{
			"000000000000000000000000",
			[]byte{
				0x16, 0x00, 0x00, 0x00, 0x07, 0x5f, 0x69, 0x64,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			},
			[]byte(`{"ID":{"$id":"000000000000000000000000"}}`),
			[]byte(`{"ID":{"$id":"000000000000000000000000"}}`),
		},
		{
			"566ee79fdd162c7ef6b89bee",
			[]byte{
				0x16, 0x00, 0x00, 0x00, 0x07, 0x5f, 0x69, 0x64,
				0x00, 0x56, 0x6e, 0xe7, 0x9f, 0xdd, 0x16, 0x2c,
				0x7e, 0xf6, 0xb8, 0x9b, 0xee, 0x00,
			},
			[]byte(`{"ID":{"$id":"566ee79fdd162c7ef6b89bee"}}`),
			[]byte(`{"ID":{"$id":"566ee79fdd162c7ef6b89bee"}}`),
		},
		{
			"566eea02dd162c827a9fcd9d",
			[]byte{
				0x16, 0x00, 0x00, 0x00, 0x07, 0x5f, 0x69, 0x64,
				0x00, 0x56, 0x6e, 0xea, 0x02, 0xdd, 0x16, 0x2c,
				0x82, 0x7a, 0x9f, 0xcd, 0x9d, 0x00,
			},
			[]byte(`{"ID":{"$id":"566eea02dd162c827a9fcd9d"}}`),
			[]byte(`{"ID":{"$id":"566eea02dd162c827a9fcd9d"}}`),
		},
		{
			"566eea26dd162c8290265b82",
			[]byte{
				0x16, 0x00, 0x00, 0x00, 0x07, 0x5f, 0x69, 0x64,
				0x00, 0x56, 0x6e, 0xea, 0x26, 0xdd, 0x16, 0x2c,
				0x82, 0x90, 0x26, 0x5b, 0x82, 0x00,
			},
			[]byte(`{"ID":{"$id":"566eea26dd162c8290265b82"}}`),
			[]byte(`{"ID":{"$id":"566eea26dd162c8290265b82"}}`),
		},
		{
			"566eea3edd162c829a5eef70",
			[]byte{
				0x16, 0x00, 0x00, 0x00, 0x07, 0x5f, 0x69, 0x64,
				0x00, 0x56, 0x6e, 0xea, 0x3e, 0xdd, 0x16, 0x2c,
				0x82, 0x9a, 0x5e, 0xef, 0x70, 0x00,
			},
			[]byte(`{"ID":{"$id":"566eea3edd162c829a5eef70"}}`),
			[]byte(`{"ID":{"$id":"566eea3edd162c829a5eef70"}}`),
		},
		{
			"566eea51dd162c82a25d7845",
			[]byte{
				0x16, 0x00, 0x00, 0x00, 0x07, 0x5f, 0x69, 0x64,
				0x00, 0x56, 0x6e, 0xea, 0x51, 0xdd, 0x16, 0x2c,
				0x82, 0xa2, 0x5d, 0x78, 0x45, 0x00,
			},
			[]byte(`{"ID":{"$id":"566eea51dd162c82a25d7845"}}`),
			[]byte(`{"ID":{"$id":"566eea51dd162c82a25d7845"}}`),
		},
		{
			"566eea51dd162c82a25d7845",
			[]byte{
				0x16, 0x00, 0x00, 0x00, 0x07, 0x5f, 0x69, 0x64,
				0x00, 0x56, 0x6e, 0xea, 0x51, 0xdd, 0x16, 0x2c,
				0x82, 0xa2, 0x5d, 0x78, 0x45, 0x00,
			},
			[]byte(`{"ID":"566eea51dd162c82a25d7845"}`),
			[]byte(`{"ID":{"$id":"566eea51dd162c82a25d7845"}}`),
		},
	}

	for _, test := range tests {
		val := TestVal{PHPObjID(bson.ObjectIdHex(test.Value))}

		jsondata, err := json.Marshal(val)
		require.Nil(t, err)
		assert.Equal(t, test.JSONOut, jsondata)

		bsondata, err := bson.Marshal(val)
		require.Nil(t, err)
		assert.Equal(t, test.BSON, bsondata)

		tval := TestVal{}

		err = json.Unmarshal(test.JSONIn, &tval)
		require.Nil(t, err)
		assert.Equal(t, val, tval)

		err = bson.Unmarshal(test.BSON, &tval)
		require.Nil(t, err)
		assert.Equal(t, val, tval)
	}
}

func TestBrokenID(t *testing.T) {
	type TestVal struct {
		ID PHPObjID `bson:"_id"`
	}

	tests := []struct {
		JSON  []byte
		Error string
	}{
		// bad hex
		{
			[]byte(`{"ID":{"$id":"badhex------------------"}}`),
			"invalid ObjectId in JSON: \"badhex------------------\" (encoding/hex: invalid byte: U+0068 'h')",
		},
		// short
		{
			[]byte(`{"ID":{"$id":"0000"}}`),
			"invalid ObjectId in JSON: \"0000\"",
		},
		// long
		{
			[]byte(`{"ID":{"$id":"0000000000000000000000000"}}`),
			"invalid ObjectId in JSON: \"0000000000000000000000000\"",
		},
		// long (bare)
		// HINT: if this test fails, make sure Go is up to date.
		{
			[]byte(`{"ID":"x000000000000000000000000"}`),
			"json: cannot unmarshal string into Go struct field TestVal.ID of type models.idWrapper",
		},
	}

	for _, test := range tests {
		val := TestVal{}
		err := json.Unmarshal(test.JSON, &val)
		require.Error(t, err)
		assert.Equal(t, test.Error, err.Error())
	}
}

func TestSentiment(t *testing.T) {
	type TestVal struct {
		DumbField Sentiment `json:"dumb_field" bson:"dumb_field"`
	}

	tests := []struct {
		Value  int
		BSON   []byte
		JSON   []byte
		Encode bool
	}{
		// simple int
		{
			0,
			[]byte{
				0x29, 0x00, 0x00, 0x00, 0x04, 0x64, 0x75, 0x6d,
				0x62, 0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x00,
				0x18, 0x00, 0x00, 0x00, 0x03, 0x30, 0x00, 0x10,
				0x00, 0x00, 0x00, 0x10, 0x76, 0x61, 0x6c, 0x75,
				0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00,
			},
			[]byte(`{"dumb_field":[{"value":0}]}`),
			true,
		},
		{
			12345,
			[]byte{
				0x29, 0x00, 0x00, 0x00, 0x04, 0x64, 0x75, 0x6d,
				0x62, 0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x00,
				0x18, 0x00, 0x00, 0x00, 0x03, 0x30, 0x00, 0x10,
				0x00, 0x00, 0x00, 0x10, 0x76, 0x61, 0x6c, 0x75,
				0x65, 0x00, 0x39, 0x30, 0x00, 0x00, 0x00, 0x00,
				0x00,
			},
			[]byte(`{"dumb_field":[{"value":12345}]}`),
			true,
		},
		// float64
		{
			20,
			[]byte{
				0x2d, 0x00, 0x00, 0x00, 0x04, 0x64, 0x75, 0x6d,
				0x62, 0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x00,
				0x1c, 0x00, 0x00, 0x00, 0x03, 0x30, 0x00, 0x14,
				0x00, 0x00, 0x00, 0x01, 0x76, 0x61, 0x6c, 0x75,
				0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x34, 0x40, 0x00, 0x00, 0x00,
			},
			[]byte(`{"dumb_field":[{"value":20}]}`),
			false,
		},
		// empty object
		{
			0,
			[]byte{
				0x1e, 0x00, 0x00, 0x00, 0x04, 0x64, 0x75, 0x6d,
				0x62, 0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x00,
				0x0d, 0x00, 0x00, 0x00, 0x03, 0x30, 0x00, 0x05,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			},
			[]byte(`{"dumb_field":[{}]}`),
			false,
		},
		// empty array
		{
			0,
			[]byte{
				0x16, 0x00, 0x00, 0x00, 0x04, 0x64, 0x75, 0x6d,
				0x62, 0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x00,
				0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
			},
			[]byte(`{"dumb_field":[]}`),
			false,
		},
		// bad data
		{
			1,
			[]byte{
				0x40, 0x00, 0x00, 0x00, 0x04, 0x64, 0x75, 0x6d,
				0x62, 0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x00,
				0x2f, 0x00, 0x00, 0x00, 0x03, 0x30, 0x00, 0x1f,
				0x00, 0x00, 0x00, 0x10, 0x76, 0x61, 0x6c, 0x75,
				0x65, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x62,
				0x6c, 0x61, 0x68, 0x00, 0x05, 0x00, 0x00, 0x00,
				0x61, 0x73, 0x64, 0x66, 0x00, 0x00, 0x03, 0x31,
				0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			},
			[]byte(`{"dumb_field":[{"value":1,"blah":"asdf"},{}]}`),
			false,
		},
		// bad data (order 2)
		{
			1,
			[]byte{
				0x40, 0x00, 0x00, 0x00, 0x04, 0x64, 0x75, 0x6d,
				0x62, 0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x00,
				0x2f, 0x00, 0x00, 0x00, 0x03, 0x30, 0x00, 0x1f,
				0x00, 0x00, 0x00, 0x02, 0x62, 0x6c, 0x61, 0x68,
				0x00, 0x05, 0x00, 0x00, 0x00, 0x61, 0x73, 0x64,
				0x66, 0x00, 0x10, 0x76, 0x61, 0x6c, 0x75, 0x65,
				0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0x31,
				0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			},
			[]byte(`{"dumb_field":[{"blah":"asdf","value":1},{}]}`),
			false,
		},
		// bad data (corruption)
		{
			0,
			[]byte{
				0x16, 0x00, 0x00, 0x00, 0x02, 0x64, 0x75, 0x6d,
				0x62, 0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x00,
				0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
			},
			[]byte(`{"dumb_field":""}`),
			false,
		},
	}

	for _, test := range tests {
		val := TestVal{}

		err := json.Unmarshal(test.JSON, &val)
		require.Nil(t, err)
		assert.Equal(t, Sentiment(test.Value), val.DumbField)

		err = bson.Unmarshal(test.BSON, &val)
		require.Nil(t, err)
		assert.Equal(t, Sentiment(test.Value), val.DumbField)

		if test.Encode {
			jsondata, err := json.Marshal(val)
			require.Nil(t, err)
			assert.Equal(t, string(test.JSON), string(jsondata))

			bsondata, err := bson.Marshal(val)
			require.Nil(t, err)
			assert.Equal(t, test.BSON, bsondata)
		}
	}
}

func TestDrupalInt(t *testing.T) {
	var v DrupalInt

	assert.Nil(t, v.UnmarshalJSON([]byte(`{"value": 1234}`)))
	assert.Equal(t, int(v), 1234)

	data, err := v.MarshalJSON()
	assert.Nil(t, err)
	assert.Equal(t, string(data), `{"value":1234}`)

	assert.Nil(t, v.UnmarshalJSON([]byte(`{"value": "567"}`)))
	assert.Equal(t, int(v), 567)

	data, err = v.MarshalJSON()
	assert.Nil(t, err)
	assert.Equal(t, string(data), `{"value":567}`)
}

func TestDrupalStr(t *testing.T) {
	type TestVal struct {
		DumbField DrupalStr `json:"dumb_field" bson:"dumb_field"`
	}

	tests := []struct {
		Value  string
		BSON   []byte
		JSON   []byte
		Encode bool
	}{
		// simple unicode
		{
			"やった！",
			[]byte{
				0x36, 0x00, 0x00, 0x00, 0x04, 0x64, 0x75, 0x6d,
				0x62, 0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x00,
				0x25, 0x00, 0x00, 0x00, 0x03, 0x30, 0x00, 0x1d,
				0x00, 0x00, 0x00, 0x02, 0x76, 0x61, 0x6c, 0x75,
				0x65, 0x00, 0x0d, 0x00, 0x00, 0x00, 0xe3, 0x82,
				0x84, 0xe3, 0x81, 0xa3, 0xe3, 0x81, 0x9f, 0xef,
				0xbc, 0x81, 0x00, 0x00, 0x00, 0x00,
			},
			[]byte(`{"dumb_field":[{"value":"やった！"}]}`),
			true,
		},
		// empty array
		{
			"",
			[]byte{
				0x16, 0x00, 0x00, 0x00, 0x04, 0x64, 0x75, 0x6d,
				0x62, 0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x00,
				0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
			},
			[]byte(`{"dumb_field":[]}`),
			false,
		},
		// bad data (corruption)
		{
			"",
			[]byte{
				0x16, 0x00, 0x00, 0x00, 0x02, 0x64, 0x75, 0x6d,
				0x62, 0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x00,
				0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
			},
			[]byte(`{"dumb_field":""}`),
			false,
		},
	}

	for _, test := range tests {
		val := TestVal{}

		err := json.Unmarshal(test.JSON, &val)
		require.Nil(t, err)
		assert.Equal(t, DrupalStr(test.Value), val.DumbField)

		err = bson.Unmarshal(test.BSON, &val)
		require.Nil(t, err)
		assert.Equal(t, DrupalStr(test.Value), val.DumbField)

		if test.Encode {
			jsondata, err := json.Marshal(val)
			require.Nil(t, err)
			assert.Equal(t, string(test.JSON), string(jsondata))

			bsondata, err := bson.Marshal(val)
			require.Nil(t, err)
			assert.Equal(t, test.BSON, bsondata)
		}
	}
}

func TestTryInt(t *testing.T) {
	tests := []struct {
		v interface{}
		e int
	}{
		{int(1), 1},
		{int32(2), 2},
		{int64(3), 3},
		{float32(4), 4},
		{float64(5), 5},
	}

	for _, test := range tests {
		assert.Equal(t, tryInt(test.v), test.e)
	}
}
